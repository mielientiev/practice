EXERCISE 1:

Write a function to get the nth Fibonacci number. The
first two Fibonacci numbers are 0 and 1, and the next number is always the sum of
the previous two. Your definition should use a local tail-recursive function.


===============================

EXERCISE 2:

Implement isSorted, which checks whether an Array[A] is sorted according to a
given comparison function.


===============================

EXERCISE 3 (hard):

Implement partial1 and write down a concrete usage of it.
There is only one possible implementation that compiles.

===============================

EXERCISE 4 (hard):
Let's look at another example, currying, which converts a function of N arguments
into a function of one argument that returns another function as its result.11
Here again, there is only one implementation that typechecks

===============================

EXERCISE 5 (optional):

Implement uncurry, which reverses the transformation of curry.
Note that since => associates to the right, A => (B => C) can be written as A => B => C.

===============================

EXERCISE 6:

Implement the higher-order function that composes two functions.

===============================